

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>codpy.core &mdash; CodPy 0.1.11 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1e825a29"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            CodPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Library Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../kernel.html">Kernel class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Kernels and maps</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_examples/index.html">Examples Gallery</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CodPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">codpy.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for codpy.core</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">codpydll</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">codpy.data_conversion</span> <span class="kn">import</span> <span class="n">get_matrix</span>
<span class="kn">from</span> <span class="nn">codpy.random_utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">codpy.selection</span> <span class="kn">import</span> <span class="n">column_selector</span>
<span class="kn">from</span> <span class="nn">codpy.utils</span> <span class="kn">import</span> <span class="n">softmaxindices</span><span class="p">,</span> <span class="n">softminindices</span>


<span class="k">class</span> <span class="nc">_codpy_param_getter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;codpy&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">get_kernel_fun</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_codpy_param_getter</span><span class="o">.</span><span class="n">get_params</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="s2">&quot;set_kernel&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="op">
<a class="viewcode-back" href="../../core.html#codpy.core.op">[docs]</a>
<span class="k">class</span> <span class="nc">op</span><span class="p">:</span>
<div class="viewcode-block" id="op.projection">
<a class="viewcode-back" href="../../core.html#codpy.core.op.projection">[docs]</a>
    <span class="k">def</span> <span class="nf">projection</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs projection in kernel regression for efficient computation, targeting a lower sampling space.</span>
<span class="sd">        Note:</span>
<span class="sd">            The performance of the function depends on two ingredients:</span>

<span class="sd">            * ``kernel`` function</span>
<span class="sd">            * ``map``</span>

<span class="sd">        Example:</span>

<span class="sd">            With NumPy arrays</span>

<span class="sd">            &gt;&gt;&gt; xtrain = np.random.randn(100, 1)</span>
<span class="sd">            &gt;&gt;&gt; xtest = np.random.randn(100, 1)</span>
<span class="sd">            &gt;&gt;&gt; fx_train = x * 2</span>
<span class="sd">            &gt;&gt;&gt; fx_test = z * 2</span>
<span class="sd">            &gt;&gt;&gt; fx_test_pred = projection(xtrain, xtrain, xtest, fx_train,</span>
<span class="sd">            kernel_fun = &quot;tensornorm&quot;, map = &quot;unitcube&quot;,</span>
<span class="sd">                   polynomial_order=2)</span>

<span class="sd">            With pandas DataFrames</span>

<span class="sd">            &gt;&gt;&gt; x_train_df = pd.DataFrame([...])</span>
<span class="sd">            &gt;&gt;&gt; y_train_df = pd.DataFrame([...])</span>
<span class="sd">            &gt;&gt;&gt; z_test_df = pd.DataFrame([...])</span>
<span class="sd">            &gt;&gt;&gt; fx_train_df = pd.DataFrame([...])</span>
<span class="sd">            &gt;&gt;&gt; projected_responses = projection(x_train_df, y_train_df, z_test_df, fx_train_df, kernel_fun = &quot;tensornorm&quot;, map = &quot;unitcube&quot;,</span>
<span class="sd">                   polynomial_order=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">project_dataframe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">column_selector</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">f_z</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">f_z</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">f_z</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">fx</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">f_z</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">index</span>
            <span class="k">return</span> <span class="n">f_z</span>

        <span class="k">def</span> <span class="nf">project_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">project_dataframe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">project_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">z</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">project_dataframe</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">project_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_weighted_projection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">projection_format_switchDict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span> <span class="k">lambda</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">projection_dataframe</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">zi</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span>
                <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">weighted_projection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">fun</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span> <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">z</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">def</span> <span class="nf">projection_dataframe</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fx&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="p">[])),</span>
            <span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">column_selector</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">f_z</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">weighted_projection</span><span class="p">(</span>
                <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">),</span> <span class="n">weights</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">f_z</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">f_z</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">fx</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">z</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f_z</span>

        <span class="n">kernel_interface</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">type_debug</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="p">[]))</span>

        <span class="k">def</span> <span class="nf">debug_fun</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fx&quot;</span><span class="p">,</span> <span class="p">[]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="p">[])),</span>
            <span class="p">)</span>
            <span class="n">f_z</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">weighted_projection</span><span class="p">(</span>
                <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">),</span> <span class="n">weights</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">f_z</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">projection_format_switchDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">type_debug</span><span class="p">,</span> <span class="n">debug_fun</span><span class="p">)</span>
        <span class="n">f_z</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">f_z</span>

<div class="viewcode-block" id="op.extrapolation">
<a class="viewcode-back" href="../../core.html#codpy.core.op.extrapolation">[docs]</a>
    <span class="k">def</span> <span class="nf">extrapolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs extrapolation in the context of kernel regression.</span>

<span class="sd">        This method leverages the kernel regression framework to extrapolate values between data points.</span>
<span class="sd">        Note:</span>
<span class="sd">            The performance of the function depends on two ingredients:</span>

<span class="sd">            * ``kernel`` function</span>
<span class="sd">            * ``map``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="n">fx</span><span class="p">)</span></div>


<div class="viewcode-block" id="op.interpolation">
<a class="viewcode-back" href="../../core.html#codpy.core.op.interpolation">[docs]</a>
    <span class="k">def</span> <span class="nf">interpolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs interpolation in the context of kernel regression.</span>

<span class="sd">        This method leverages the kernel regression framework to interpolate values between data points.</span>
<span class="sd">        Note:</span>
<span class="sd">            The performance of the function depends on two ingredients:</span>

<span class="sd">            * ``kernel`` function</span>
<span class="sd">            * ``map``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="n">fx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="op.gradient_denoiser">
<a class="viewcode-back" href="../../core.html#codpy.core.op.gradient_denoiser">[docs]</a>
    <span class="k">def</span> <span class="nf">gradient_denoiser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function for performing least squares regression penalized by the norm of the gradient,</span>
<span class="sd">        induced by a positive definite (PD) kernel.</span>

<span class="sd">        This functioon initializes with various parameters and sets up a regression framework</span>
<span class="sd">        that includes regularization based on the gradient&#39;s magnitude. It is designed to</span>
<span class="sd">        work with gradient norms induced by a PD kernel.</span>
<span class="sd">        Returns:</span>
<span class="sd">            The denoised output for the input data.</span>

<span class="sd">        Example:</span>

<span class="sd">        Initialize the denoiser with input data &#39;x&#39; and optional parameters</span>

<span class="sd">        &gt;&gt;&gt; xtrain = np.random.randn(100, 1)</span>
<span class="sd">        &gt;&gt;&gt; xtest = np.random.randn(100, 1)</span>
<span class="sd">        &gt;&gt;&gt; fx_train = x * 2</span>
<span class="sd">        &gt;&gt;&gt; fx_test = z * 2</span>

<span class="sd">        # Perform denoising on the input data or new data points &#39;z&#39;</span>
<span class="sd">        op.denoiser(xtrain, xtest, fx_train, kernel_fun = &quot;maternnorm&quot;, map = &quot;standardmean&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">diffops</span><span class="o">.</span><span class="n">nablaT_nabla</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">extrapolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="n">fx</span><span class="p">)</span>
        <span class="c1"># self.reg = self.epsilon*op.nablaT_nabla(**{**kw,**{&#39;fx&#39;:[],&#39;y&#39;:self.y,&#39;x&#39;:self.x}})</span>
        <span class="c1"># self.kernel = kernel_setters.kernel_helper(kernel_setters.set_matern_normkernel, 0,1e-8 ,map_setters.set_standard_mean_map)</span>
        <span class="c1"># out = op.extrapolation(**{**self.params,**{&#39;z&#39;:z}})</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="op.norm">
<a class="viewcode-back" href="../../core.html#codpy.core.op.norm">[docs]</a>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the kernel-induced norm based on the provided matrices.</span>

<span class="sd">        This function computes a norm projection using the kernel initialization parameters.</span>
<span class="sd">        It supports flexible argument input through keyword arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (list, optional): The first matrix. Defaults to an empty list.</span>
<span class="sd">            y (list, optional): The second matrix. Defaults to a list containing `x`.</span>
<span class="sd">            z (list, optional): The third matrix. Defaults to an empty list.</span>
<span class="sd">            fx (list, optional): The fourth matrix. Defaults to an empty list.</span>
<span class="sd">        Note:</span>
<span class="sd">            The performance of the function depends on two ingredients:</span>

<span class="sd">            * ``kernel`` function</span>
<span class="sd">            * ``map``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">norm_projection</span><span class="p">(</span>
            <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="op.coefficients">
<a class="viewcode-back" href="../../core.html#codpy.core.op.coefficients">[docs]</a>
    <span class="k">def</span> <span class="nf">coefficients</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the regressors or coefficients for kernelized regression, using a specified PD kernel.</span>

<span class="sd">        This method initializes the kernel function with the given parameters and then</span>
<span class="sd">        computes the regression coefficients based on the input datasets.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.array): The input data points for which the regression coefficients are computed.</span>
<span class="sd">            y (np.array): Internal parameter, can be y = x.</span>
<span class="sd">            fx (np.array, optional): Responses associated with &#39;x&#39;.</span>


<span class="sd">        Returns:</span>
<span class="sd">            np.array: The computed regression coefficients or regressors that model the</span>
<span class="sd">            relationship between the input data &#39;x&#39; and the target &#39;y&#39;.</span>


<span class="sd">        Available Kernels:</span>

<span class="sd">            - ``&#39;gaussian&#39;``: Gaussian kernel for smooth, continuous functions.</span>
<span class="sd">            - ``&#39;tensornorm&#39;``: Tensor norm kernel suitable for multidimensional data.</span>
<span class="sd">            - ``&#39;absnorm&#39;``: Absolute norm kernel for robust performance in varied datasets.</span>
<span class="sd">            - ``&#39;matern&#39;``: Matérn kernel useful in spatial statistics.</span>
<span class="sd">            - ``&#39;multiquadricnorm&#39;``: Multi-quadric norm kernel for flexible shape adaptation.</span>
<span class="sd">            - ``&#39;multiquadrictensor&#39;``: Multi-quadric tensor kernel, a tensor-based variant offering flexible shape adaptation.</span>
<span class="sd">            - ``&#39;sincardtensor&#39;``: Sinc cardinal tensor kernel, suitable for periodic and oscillatory data.</span>
<span class="sd">            - ``&#39;sincardsquaretensor&#39;``: Sinc cardinal square tensor kernel, enhancing the sinc cardinal tensor kernel for certain data types.</span>
<span class="sd">            - ``&#39;dotproduct&#39;``: Dot product kernel, useful for linear classifications and regressions.</span>
<span class="sd">            - ``&#39;gaussianper&#39;``: Gaussian periodic kernel, ideal for modeling periodic functions.</span>
<span class="sd">            - ``&#39;maternnorm&#39;``: Matérn norm kernel, a variation of the Matérn kernel for normalized spaces.</span>
<span class="sd">            - ``&#39;scalarproduct&#39;``: Scalar product kernel, a simple yet effective kernel for dot products.</span>

<span class="sd">        Available Maps:</span>

<span class="sd">            - ``&#39;linear&#39;``: Linear map for straightforward transformations.</span>
<span class="sd">            - ``&#39;affine&#39;``: Affine map for linear transformations with translation.</span>
<span class="sd">            - ``&#39;log&#39;``: Logarithmic map for non-linear scaling.</span>
<span class="sd">            - ``&#39;exp&#39;``: Exponential map for rapidly increasing scales.</span>
<span class="sd">            - ``&#39;scalestd&#39;``: Standard scaling map that normalizes data by removing the mean and scaling to unit variance.</span>
<span class="sd">            - ``&#39;erf&#39;``: Error function map, useful for data normalization with a non-linear scale.</span>
<span class="sd">            - ``&#39;erfinv&#39;``: Inverse error function map, providing the inverse transformation of the error function.</span>
<span class="sd">            - ``&#39;scalefactor&#39;``: Scaling factor map that applies a uniform scaling defined by a bandwidth or scale factor.</span>
<span class="sd">            - ``&#39;bandwidth&#39;``: Helper for setting the scale factor map with a specified bandwidth, typically used in kernel methods.</span>
<span class="sd">            - ``&#39;grid&#39;``: Grid map that projects data onto a grid, useful for discretizing continuous variables or spatial data.</span>
<span class="sd">            - ``&#39;unitcube&#39;``: Unit cube map that scales data to fit within a unit cube, ensuring all features are within the range [0,1].</span>
<span class="sd">            - ``&#39;meandistance&#39;``: Mean distance map that scales data based on the mean distance between data points.</span>
<span class="sd">            - ``&#39;mindistance&#39;``: Minimum distance map that scales data based on the minimum distance between data points.</span>
<span class="sd">            - ``&#39;standardmin&#39;``: Standard minimum map pipeline combining minimum distance scaling with other transformations.</span>
<span class="sd">            - ``&#39;standardmean&#39;``: Standard mean map pipeline combining mean distance scaling with other transformations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">coefficients</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">),</span> <span class="p">[])</span></div>


    <span class="c1"># @cache</span>
<div class="viewcode-block" id="op.Knm">
<a class="viewcode-back" href="../../core.html#codpy.core.op.Knm">[docs]</a>
    <span class="k">def</span> <span class="nf">Knm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fy</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the kernel matrix induced by a positive definite (pd) kernel.</span>

<span class="sd">        This method calculates the kernel matrix k(x_i,y_j) using the input kernel function.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray`): Input data points for the gradient computation. np.array of size N , D.</span>
<span class="sd">            y (:class:`numpy.ndarray`): Secondary data points used in the kernel computation. np.array of size M , D.</span>
<span class="sd">            fx (:class:`numpy.ndarray`): optional-Function values or responses at the data points in `x`. np.array of size M , Df.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - if fx is empty: matrix np.array of size (NxM) The computed kernel matrix, representing the kernel-induced distances or similarities between the data points in &#39;x&#39; and &#39;y&#39;.</span>
<span class="sd">            - prod(Knm(x,y),fx) else. This allow performance and memory optimizations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Knm</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fy</span><span class="p">))</span></div>


<div class="viewcode-block" id="op.Knm_inv">
<a class="viewcode-back" href="../../core.html#codpy.core.op.Knm_inv">[docs]</a>
    <span class="k">def</span> <span class="nf">Knm_inv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">,</span> <span class="n">reg_matrix</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray`): Input data points for the gradient computation. np.array of size N , D.</span>
<span class="sd">            y (:class:`numpy.ndarray`): Secondary data points used in the kernel computation. np.array of size M , D.</span>
<span class="sd">            fx (:class:`numpy.ndarray`): optional-Function values or responses at the data points in `x`. np.array of size M , Df.</span>
<span class="sd">        Returns:</span>
<span class="sd">            - if reg is empty:</span>
<span class="sd">                - if fx is empty: matrix np.array of size (NxM), that is the least square inverse of Knm(x,y).</span>
<span class="sd">                - prod(Knm_inv(x,y),fx) else. This allow performance and memory optimizations. The output corresponds then to the coefficient of fx in the kernel induced basis.</span>
<span class="sd">            - else:</span>
<span class="sd">                - if fx is empty: matrix np.array of size (NxM), that corresponds to the least square computation (Knm(y,x)Knm(x,y)+reg)^{-1}Knm(y,x).</span>
<span class="sd">                - prod(Knm_inv(x,y),fx) else. This allow performance and memory optimizations. The output corresponds then to the coefficient of fx in the kernel induced basis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Knm_inv</span><span class="p">(</span>
            <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">reg_matrix</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="op.Dnm">
<a class="viewcode-back" href="../../core.html#codpy.core.op.Dnm">[docs]</a>
    <span class="k">def</span> <span class="nf">Dnm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a distance matrix induced by a positive definite (pd) kernel.</span>

<span class="sd">        This function calculates the distance matrix between sets of data points</span>
<span class="sd">        x and y based on a specified pd kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.array): The first set of data points.</span>
<span class="sd">            y (np.array): The second set of data points. If not provided, defaults to x.</span>
<span class="sd">            distance (function, optional): a name of distance function.</span>
<span class="sd">        :type kwargs: dict</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: A distance matrix representing the distances between each pair of points in x and y as induced by the pd kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Dnm</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">distance</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Dnm</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">))</span></div>


<div class="viewcode-block" id="op.discrepancy_error">
<a class="viewcode-back" href="../../core.html#codpy.core.op.discrepancy_error">[docs]</a>
    <span class="k">def</span> <span class="nf">discrepancy_error</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">disc_type</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">discrepancy_error</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">disc_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="op.norm_projection">
<a class="viewcode-back" href="../../core.html#codpy.core.op.norm_projection">[docs]</a>
    <span class="k">def</span> <span class="nf">norm_projection</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">norm_projection</span><span class="p">(</span>
            <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
        <span class="p">)</span></div>
</div>


<div class="viewcode-block" id="misc">
<a class="viewcode-back" href="../../core.html#codpy.core.misc">[docs]</a>
<span class="k">class</span> <span class="nc">misc</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Miscellaneous kernel functions or classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="misc.distance_labelling">
<a class="viewcode-back" href="../../core.html#codpy.core.misc.distance_labelling">[docs]</a>
    <span class="k">def</span> <span class="nf">distance_labelling</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxmin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes and labels distances using a kernel-induced distance matrix.</span>

<span class="sd">        This function calculates the distance matrix between two sets of data points (x and y) using</span>
<span class="sd">        a specified kernel function. It then labels these distances based on either the softmax or softmin</span>
<span class="sd">        indices, depending on the &#39;max&#39; parameter in kwargs.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (np.array): The first set of data points.</span>
<span class="sd">            y (np.array): The second set of data points.</span>
<span class="sd">            axis (int, optional): The axis along which to compute the distances. Default is 1.</span>
<span class="sd">            max (bool, optional): Determines the type of labelling:</span>
<span class="sd">                - If True, uses softmax labelling.</span>
<span class="sd">                - If False (default), uses softmin labelling.</span>
<span class="sd">                :param kernel_fun: The name of the kernel function to use. Options include ``&#39;gaussian&#39;``, ``&#39;tensornorm&#39;``, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: An array of labelled distances between the data points in x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;######&#39;,&#39;distance_labelling&#39;,&#39;######&#39;)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">Dnm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxmin</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">softminindices</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">softmaxindices</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">label</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices</span></div>



<div class="viewcode-block" id="misc.discrepancy">
<a class="viewcode-back" href="../../core.html#codpy.core.misc.discrepancy">[docs]</a>
    <span class="k">def</span> <span class="nf">discrepancy</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">disc_type</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;discrepancy:xmax&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">random_select_interface</span><span class="p">(</span>
                <span class="n">xmaxlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:xmax&quot;</span><span class="p">,</span>
                <span class="n">seedlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:seed&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;discrepancy:ymax&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">random_select_interface</span><span class="p">(</span>
                <span class="n">xmaxlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:ymax&quot;</span><span class="p">,</span>
                <span class="n">seedlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:seed&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;discrepancy:zmax&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">random_select_interface</span><span class="p">(</span>
                <span class="n">xmaxlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:zmax&quot;</span><span class="p">,</span>
                <span class="n">seedlabel</span><span class="o">=</span><span class="s2">&quot;discrepancy:seed&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">z</span><span class="p">}},</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">debug</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">discrepancy_error</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">disc_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                <span class="n">debug</span> <span class="o">+=</span> <span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">discrepancy_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">disc_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">debug</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cd</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">discrepancy_error</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">disc_type</span><span class="p">))</span></div>



<div class="viewcode-block" id="misc.discrepancy_functional">
<a class="viewcode-back" href="../../core.html#codpy.core.misc.discrepancy_functional">[docs]</a>
    <span class="k">class</span> <span class="nc">discrepancy_functional</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A kernel-induced discrepancy between two distributions.</span>

<span class="sd">        Discrepancy is a non-parametric method to test the equality of two distributions. It&#39;s computed in a</span>
<span class="sd">        Reproducing Kernel Hilbert Space (RKHS) using a specified kernel function.</span>

<span class="sd">        Attributes:</span>
<span class="sd">        Nx (int): The number of samples in the first distribution &#39;x&#39;.</span>
<span class="sd">        x (array-like): The first distribution for which MMD is to be computed.</span>
<span class="sd">        Kxx (float): The kernel-induced distance computed within &#39;x&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (array-like): The first input distribution.</span>
<span class="sd">            y (array-like, optional): The second input distribution. If not provided, it defaults to an empty list.</span>
<span class="sd">            **kwargs: Additional keyword arguments for the kernel function.</span>

<span class="sd">        Methods:</span>
<span class="sd">            eval(ys, **kwargs): Computes the MMD between the distribution &#39;ys&#39; and the initial distribution &#39;x&#39;.</span>

<span class="sd">        Example:</span>
<span class="sd">            Define two distributions</span>

<span class="sd">            &gt;&gt;&gt; x = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y = np.array([...])</span>

<span class="sd">            Initialize discrepancy functional for &#39;x&#39;</span>

<span class="sd">            &gt;&gt;&gt; discrepancy = discrepancy_functional(x)</span>

<span class="sd">            Compute MMD between &#39;x&#39; and &#39;y&#39;</span>

<span class="sd">            &gt;&gt;&gt; discrepancy_value = discrepancy.eval(y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="misc.discrepancy_functional.__init__">
<a class="viewcode-back" href="../../core.html#codpy.core.misc.discrepancy_functional.__init__">[docs]</a>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="n">fx</span><span class="p">,</span>
            <span class="n">kernel_fun</span><span class="o">=</span><span class="s2">&quot;tensornorm&quot;</span><span class="p">,</span>
            <span class="nb">map</span><span class="o">=</span><span class="s2">&quot;unitcube&quot;</span><span class="p">,</span>
            <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
            <span class="n">reg</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">[],</span>
            <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Args:</span>

<span class="sd">            :param kernel_fun: The name of the kernel function to use. Options include ``&#39;gaussian&#39;``, ``&#39;tensornorm&#39;``, etc.</span>
<span class="sd">            :type kernel_fun: :class:`str`, optional</span>
<span class="sd">            :param map: The name of the mapping function to apply. Options include ``&#39;linear&#39;``, ``&#39;affine&#39;``, etc.</span>
<span class="sd">            :type map: :class:`str`, optional</span>
<span class="sd">            :param polynomial_order: The polynomial order for the kernel function. Defaults to ``2``.</span>
<span class="sd">            :type polynomial_order: :class:`float`, optional</span>
<span class="sd">            :param regularization: Regularization parameter for the kernel. Defaults to ``1e-8``.</span>
<span class="sd">            :type regularization: :class:`numpy.ndarray`, optional</span>
<span class="sd">            :param rescale: Whether to rescale the data.</span>
<span class="sd">            :type rescale: :class:`bool`, optional</span>
<span class="sd">            :param rescale_params: Parameters for data rescaling. Defaults to ``{&#39;max&#39;: 1000, &#39;seed&#39;: 42}``.</span>
<span class="sd">            :type rescale_params: :class:`dict`, optional</span>
<span class="sd">            :param kwargs: Arbitrary keyword arguments.</span>
<span class="sd">            :type kwargs: dict</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Kxx</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">Knm</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">fx</span><span class="p">,</span>
                <span class="n">Kinv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">kernel_fun</span><span class="o">=</span><span class="n">kernel_fun</span><span class="p">,</span>
                <span class="nb">map</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span>
                <span class="n">polynomial_order</span><span class="o">=</span><span class="n">polynomial_order</span><span class="p">,</span>
                <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span>
                <span class="n">reg</span><span class="o">=</span><span class="n">reg</span><span class="p">,</span>
                <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Kxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Kxx</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span>
            <span class="k">pass</span></div>


<div class="viewcode-block" id="misc.discrepancy_functional.eval">
<a class="viewcode-back" href="../../core.html#codpy.core.misc.discrepancy_functional.eval">[docs]</a>
        <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ys</span><span class="p">,</span>
            <span class="n">fx</span><span class="p">,</span>
            <span class="n">Kinv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">kernel_fun</span><span class="o">=</span><span class="s2">&quot;tensornorm&quot;</span><span class="p">,</span>
            <span class="nb">map</span><span class="o">=</span><span class="s2">&quot;unitcube&quot;</span><span class="p">,</span>
            <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">regularization</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="n">reg</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Args:</span>

<span class="sd">            :param kernel_fun: The name of the kernel function to use. Options include ``&#39;gaussian&#39;``, ``&#39;tensornorm&#39;``, etc.</span>
<span class="sd">            :type kernel_fun: :class:`str`, optional</span>
<span class="sd">            :param map: The name of the mapping function to apply. Options include ``&#39;linear&#39;``, ``&#39;affine&#39;``, etc.</span>
<span class="sd">            :type map: :class:`str`, optional</span>
<span class="sd">            :param polynomial_order: The polynomial order for the kernel function. Defaults to ``2``.</span>
<span class="sd">            :type polynomial_order: :class:`float`, optional</span>
<span class="sd">            :param regularization: Regularization parameter for the kernel. Defaults to ``1e-8``.</span>
<span class="sd">            :type regularization: :class:`numpy.ndarray`, optional</span>
<span class="sd">            :param rescale: Whether to rescale the data.</span>
<span class="sd">            :type rescale: :class:`bool`, optional</span>
<span class="sd">            :param rescale_params: Parameters for data rescaling. Defaults to ``{&#39;max&#39;: 1000, &#39;seed&#39;: 42}``.</span>
<span class="sd">            :type rescale_params: :class:`dict`, optional</span>
<span class="sd">            :param kwargs: Arbitrary keyword arguments.</span>
<span class="sd">            :type kwargs: dict</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
            <span class="n">Kxy</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">Knm</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">ys</span><span class="p">,</span>
                <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                <span class="n">fx</span><span class="o">=</span><span class="n">fx</span><span class="p">,</span>
                <span class="n">Kinv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">kernel_fun</span><span class="o">=</span><span class="n">kernel_fun</span><span class="p">,</span>
                <span class="nb">map</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span>
                <span class="n">polynomial_order</span><span class="o">=</span><span class="n">polynomial_order</span><span class="p">,</span>
                <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span>
                <span class="n">reg</span><span class="o">=</span><span class="n">reg</span><span class="p">,</span>
                <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nx</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Kxx</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Kxy</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span></div>
</div>
</div>



<div class="viewcode-block" id="diffops">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops">[docs]</a>
<span class="k">class</span> <span class="nc">diffops</span><span class="p">:</span>
<div class="viewcode-block" id="diffops.nabla_Knm">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nabla_Knm">[docs]</a>
    <span class="k">def</span> <span class="nf">nabla_Knm</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">fy</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nabla_Knm</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fy</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.nabla">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nabla">[docs]</a>
    <span class="k">def</span> <span class="nf">nabla</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the kernel-induced gradient of a function.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points for the gradient computation.</span>
<span class="sd">            y (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Secondary data points used in the kernel computation.</span>
<span class="sd">            z (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Tertiary data points used in the kernel computation.</span>
<span class="sd">            fx (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Function values or responses at the data points in `x`.</span>


<span class="sd">        Returns:</span>
<span class="sd">            :class:`numpy.ndarray`: The computed gradient of the function.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; x = np.random.randn(100, 1)</span>
<span class="sd">            &gt;&gt;&gt; z = np.random.randn(100, 1)</span>
<span class="sd">            &gt;&gt;&gt; fx = x * 2</span>
<span class="sd">            &gt;&gt;&gt; fz = z * 2</span>
<span class="sd">            &gt;&gt;&gt; gradient = diffops.nabla(x,x,z,fx)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.nabla_inv">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nabla_inv">[docs]</a>
    <span class="k">def</span> <span class="nf">nabla_inv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fz</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the inverse of the kernel-induced gradient operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points.</span>
<span class="sd">            y (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Secondary data points.</span>
<span class="sd">            z (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Tertiary data points.</span>
<span class="sd">            fz (:class:`numpy.ndarray`, optional): The vector field for the inverse gradient computation.</span>


<span class="sd">        Returns:</span>
<span class="sd">            :class:`numpy.ndarray`: The computed inverse gradient of the vector field.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; z_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; vector_field = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; inv_gradient = nabla_inv(x_data, y_data, z_data, fz=vector_field)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nabla_inv</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">fz</span><span class="p">)</span></div>


<div class="viewcode-block" id="diffops.nablaT">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nablaT">[docs]</a>
    <span class="k">def</span> <span class="nf">nablaT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fz</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the divergence of a vector field using a kernel-induced method.</span>

<span class="sd">        This function calculates the divergence (nabla transpose) of a vector field in the context of kernel methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            x class:`numpy.ndarray`: The input data points where the divergence is calculated.</span>
<span class="sd">            y class:`numpy.ndarray`: Secondary data points used in the kernel computation.</span>
<span class="sd">            z class:`numpy.ndarray`: Tertiary data points used in the kernel computation.</span>
<span class="sd">            fz class:`numpy.ndarray`: The vector field for which the divergence is computed. Defaults to an empty list.</span>


<span class="sd">        Returns:</span>
<span class="sd">            class:`numpy.ndarray`: The computed divergence of the vector field at each point in `x`.</span>

<span class="sd">        Example:</span>
<span class="sd">            Example usage with NumPy arrays</span>

<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; z_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; vector_field = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; divergence = nablaT(x_data, y_data, z_data, fz=vector_field)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nablaT</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fz</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.nablaT_inv">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nablaT_inv">[docs]</a>
    <span class="k">def</span> <span class="nf">nablaT_inv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the inverse of the transposed gradient operation.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points.</span>
<span class="sd">            y (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Secondary data points.</span>
<span class="sd">            z (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Tertiary data points.</span>
<span class="sd">            fx (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Function values or responses at the data points.</span>


<span class="sd">        Returns:</span>
<span class="sd">            :class:`numpy.ndarray`: The computed inverse of the transposed gradient.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; z_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; fx_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; inv_transpose_gradient = nablaT_inv(x_data, y_data, z_data, fx_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nablaT_inv</span><span class="p">(</span>
            <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="diffops.nablaT_nabla">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nablaT_nabla">[docs]</a>
    <span class="k">def</span> <span class="nf">nablaT_nabla</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the kernel-induced discrete Laplace operator.</span>

<span class="sd">        This function calculates the discrete Laplace operator using a kernel method. It computes this</span>
<span class="sd">        operator as the dot product of the transposed gradient vector and the gradient vector, which is</span>
<span class="sd">        consistent with a differential operator that resembles the Laplace operator in its behavior.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points for the Laplace operator computation.</span>
<span class="sd">            y (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Secondary data points used in the kernel computation.</span>
<span class="sd">            fx (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Function values or responses at the data points.</span>

<span class="sd">            class:`numpy.ndarray`: The computed discrete Laplace operator values for each point in `x`.</span>

<span class="sd">        Note:</span>
<span class="sd">            The discrete Laplace operator computed here is not consistent with the &quot;true&quot; Laplace operator,</span>
<span class="sd">            but instead aligns with another differential operator, described as \(-\nabla \cdot (\nabla f\mu)\).</span>

<span class="sd">        Example:</span>
<span class="sd">            Example usage with NumPy arrays</span>

<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; fx_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; laplace_operator = nablaT_nabla(x_data, y_data, fx_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nablaT_nabla</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">fx</span><span class="o">=</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.nablaT_nabla_inv">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.nablaT_nabla_inv">[docs]</a>
    <span class="k">def</span> <span class="nf">nablaT_nabla_inv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">nablaT_nabla_inv</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.Leray_T">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.Leray_T">[docs]</a>
    <span class="k">def</span> <span class="nf">Leray_T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Leray_T</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.Leray">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.Leray">[docs]</a>
    <span class="k">def</span> <span class="nf">Leray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Leray operator for a given set of input matrices.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points.</span>
<span class="sd">            y (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Secondary data points.</span>
<span class="sd">            fx (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Function values or responses at the data points.</span>
<span class="sd">            **kwargs (dict): Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`numpy.ndarray` or :class:`pandas.DataFrame`: The result of the Leray operator computation.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; y_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; fx_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; leray_result = Leray(x_data, y_data, fx_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">Leray</span><span class="p">(</span><span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">))</span></div>


<div class="viewcode-block" id="diffops.hessian">
<a class="viewcode-back" href="../../core.html#codpy.core.diffops.hessian">[docs]</a>
    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the kernel-induced Hessian matrix of a function</span>

<span class="sd">        Args:</span>
<span class="sd">            x (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points where the Hessian matrix is calculated.</span>
<span class="sd">            z (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Tertiary data points used in the kernel computation.</span>
<span class="sd">            fx (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Function values or responses at the data points in `x`.</span>


<span class="sd">        Returns:</span>
<span class="sd">            :class:`numpy.ndarray`: The computed Hessian matrix of the function.</span>

<span class="sd">        Note:</span>
<span class="sd">            The function computes the Hessian matrix for each input data point. If the &#39;fx&#39; parameter is provided,</span>
<span class="sd">            the function computes a modified Hessian matrix using this additional information.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; x_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; z_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; fx_data = np.array([...])</span>
<span class="sd">            &gt;&gt;&gt; hessian_matrix = hessian(x_data, z_data, fx_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">distance_labelling</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">diffops</span><span class="o">.</span><span class="n">nabla</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
            <span class="n">fx</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">kernel_fun</span><span class="o">=</span><span class="n">kernel_fun</span><span class="p">,</span>
            <span class="nb">map</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span>
            <span class="n">polynomial_order</span><span class="o">=</span><span class="n">polynomial_order</span><span class="p">,</span>
            <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span>
            <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">N_X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># N_Z = z.shape[0]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gradT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_X</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">N_X</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">gradT</span><span class="p">[:,</span> <span class="n">d</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grad</span><span class="p">[:,</span> <span class="n">d</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="p">[</span><span class="n">helper</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">fx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
            <span class="c1"># gradf = np.squeeze(op.nabla(x=x, y=y, z=x, fx=np.squeeze(fx),**kwargs))</span>
            <span class="c1"># spot_baskets = z[:,1]</span>
            <span class="c1"># thetas = gradf[:,0]</span>
            <span class="c1"># deltas = gradf[:,1]</span>
            <span class="c1"># multi_plot([[z,thetas],[z,deltas]],plotD,projection=&#39;3d&#39;,loc = &#39;upper left&#39;,prop={&#39;size&#39;: 3},mp_ncols=2,**kwargs)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_X</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">)):</span>
                <span class="n">debug</span> <span class="o">=</span> <span class="n">grad</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span>
                <span class="c1"># multi_plot([[z,debug]],plotD,projection=&#39;3d&#39;,loc = &#39;upper left&#39;,prop={&#39;size&#39;: 3},mp_ncols=2,**kwargs)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">gradT</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">mat</span> <span class="o">@</span> <span class="n">debug</span>
                <span class="c1"># multi_plot([[z,out[:,d[0], d[1],:]]],plotD,projection=&#39;3d&#39;,loc = &#39;upper left&#39;,prop={&#39;size&#39;: 3},mp_ncols=2,**kwargs)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># codpy_hessians = np.squeeze(out)</span>
            <span class="c1"># thetas = codpy_hessians[:,0,0]</span>
            <span class="c1"># gammas = codpy_hessians[:,1,1]</span>
            <span class="c1"># crossed = codpy_hessians[:,1,0]</span>
            <span class="c1"># multi_plot([[z,fx],[z,thetas],[z,gammas],[z,crossed]],plotD,projection=&#39;3d&#39;,loc = &#39;upper left&#39;,prop={&#39;size&#39;: 3},mp_ncols=2,**kwargs)</span>

            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N_X</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">N_X</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">)):</span>
                <span class="n">hess</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradT</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">grad</span><span class="p">[:,</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
                <span class="c1"># test = hess[:,d[0]*D + d[1],:]</span>
            <span class="k">return</span> <span class="n">hess</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span></div>
</div>



<div class="viewcode-block" id="factories">
<a class="viewcode-back" href="../../core.html#codpy.core.factories">[docs]</a>
<span class="k">class</span> <span class="nc">factories</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manipulate built-in codpy factories.</span>
<span class="sd">    </span>
<span class="sd">    Note: two kinds of factories are exhibited</span>
<span class="sd">        - Kernel factories through :func:`factories.get_kernel_factory()`, defining real-valued function $k(x,y)$ from a positive-definite kernel.</span>
<span class="sd">        - Maps factories through :func:`factories.get_map_factory()`, defining maps $x\mapsto S(x)$, used to fit the data to a kernel using $k\circ S$.</span>
<span class="sd">    Users can overload these factories to add their own kernels and map, see :meth:`kernel_overloading.my_kernel_overloading`</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="factories.check_map_strings">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.check_map_strings">[docs]</a>
    <span class="k">def</span> <span class="nf">check_map_strings</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simply check that the string, or list of strings, are keys for the dictionary :func:`factories.get_map_factory_keys()`</span>

<span class="sd">        Args:</span>
<span class="sd">            strings : (:class:`str` or :class:`list`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="p">[</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">check_map_strings</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="n">strings</span> <span class="ow">in</span> <span class="n">factories</span><span class="o">.</span><span class="n">get_map_factory_keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;unknown map:&quot;</span> <span class="o">+</span> <span class="n">strings</span><span class="p">)</span></div>



<div class="viewcode-block" id="factories.check_kernel_strings">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.check_kernel_strings">[docs]</a>
    <span class="k">def</span> <span class="nf">check_kernel_strings</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simply check that the string, or list of strings, are keys in the dictionary :func:`factories.get_kernel_factory_keys()`</span>

<span class="sd">        Args:</span>
<span class="sd">            strings : (:class:`str` or :class:`list`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">strings</span> <span class="ow">in</span> <span class="n">factories</span><span class="o">.</span><span class="n">get_kernel_factory_keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;unknown kernel:&quot;</span> <span class="o">+</span> <span class="n">strings</span><span class="p">)</span></div>


<div class="viewcode-block" id="factories.get_kernel_factory">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.get_kernel_factory">[docs]</a>
    <span class="k">def</span> <span class="nf">get_kernel_factory</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">factories</span><span class="o">.</span><span class="n">get_kernels_factory</span><span class="p">()</span></div>

<div class="viewcode-block" id="factories.get_kernel_factory_keys">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.get_kernel_factory_keys">[docs]</a>
    <span class="k">def</span> <span class="nf">get_kernel_factory_keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">factories</span><span class="o">.</span><span class="n">kernel_factory_keys</span><span class="p">()</span></div>


<div class="viewcode-block" id="factories.get_map_factory">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.get_map_factory">[docs]</a>
    <span class="k">def</span> <span class="nf">get_map_factory</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">factories</span><span class="o">.</span><span class="n">get_maps_factory</span><span class="p">()</span></div>

<div class="viewcode-block" id="factories.get_map_factory_keys">
<a class="viewcode-back" href="../../core.html#codpy.core.factories.get_map_factory_keys">[docs]</a>
    <span class="k">def</span> <span class="nf">get_map_factory_keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">factories</span><span class="o">.</span><span class="n">maps_factory_keys</span><span class="p">()</span></div>
</div>


<div class="viewcode-block" id="kernel_interface">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface">[docs]</a>
<span class="k">class</span> <span class="nc">kernel_interface</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Miscellaneous instructions to instruct the C++ interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="kernel_interface.set_verbose">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_verbose">[docs]</a>
    <span class="k">def</span> <span class="nf">set_verbose</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce a diagnosis file &quot;output.xml&quot; to debug, profile or audit the C++ core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">verbose</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span></div>



<div class="viewcode-block" id="kernel_interface.set_num_threads">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_num_threads">[docs]</a>
    <span class="k">def</span> <span class="nf">set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limit the number of threads used by the C++ core.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.rescale">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.rescale">[docs]</a>
    <span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[],</span> <span class="n">z</span><span class="o">=</span><span class="p">[],</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intruct the kernel map to fit its parameters in order to match the variables $x,y,z$.</span>

<span class="sd">        Args:</span>
<span class="sd">            x,y,z (:class:`numpy.ndarray` or :class:`pandas.DataFrame`): Input data points to fit.</span>
<span class="sd">            max : (:class:`int`). Random select max datapoints. Used to limit the input size for performances. </span>
<span class="sd">            seed : (:class:`int`). The seed used to random selection. See (:class:`max`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">random_select</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">),</span>
                <span class="n">random_select</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">),</span>
                <span class="n">random_select</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">get_matrix</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.get_kernel_ptr">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.get_kernel_ptr">[docs]</a>
    <span class="k">def</span> <span class="nf">get_kernel_ptr</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a smart pointer to the current kernel used by codpy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cd</span><span class="o">.</span><span class="n">get_kernel_ptr</span><span class="p">()</span></div>


<div class="viewcode-block" id="kernel_interface.set_kernel_ptr">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_kernel_ptr">[docs]</a>
    <span class="k">def</span> <span class="nf">set_kernel_ptr</span><span class="p">(</span><span class="n">kernel_ptr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set codpy with a kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">set_kernel_ptr</span><span class="p">(</span><span class="n">kernel_ptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.set_polynomial_order">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_polynomial_order">[docs]</a>
    <span class="k">def</span> <span class="nf">set_polynomial_order</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow to set an integer, used for polynomial regression with codpy&#39;s internal kernels.</span>

<span class="sd">        Args:</span>
<span class="sd">            order : (:class:`int`). The order for polynomial regression :</span>
<span class="sd">                - 0 means regression on a constant (one regression)</span>
<span class="sd">                - 1 means constant and linear regression (one + $D$ regression).</span>
<span class="sd">                - 2 means constant, linear regression and quadratic regression (one + $D$ + $D^2$ regression)..</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_polynomial_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.set_regularization">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_regularization">[docs]</a>
    <span class="k">def</span> <span class="nf">set_regularization</span><span class="p">(</span><span class="n">regularization</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a float value for Tykhonov regularization in kernel ridge inversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.pipe_kernel_ptr">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.pipe_kernel_ptr">[docs]</a>
    <span class="k">def</span> <span class="nf">pipe_kernel_ptr</span><span class="p">(</span><span class="n">kernel_ptr</span><span class="p">):</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">pipe_kernel_ptr</span><span class="p">(</span><span class="n">kernel_ptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.pipe_kernel_fun">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.pipe_kernel_fun">[docs]</a>
    <span class="k">def</span> <span class="nf">pipe_kernel_fun</span><span class="p">(</span><span class="n">kernel_fun</span><span class="p">,</span> <span class="n">regularization</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="n">kern1</span> <span class="o">=</span> <span class="n">kernel_interface</span><span class="o">.</span><span class="n">get_kernel_ptr</span><span class="p">()</span>
        <span class="n">kernel_fun</span><span class="p">()</span>
        <span class="n">kern2</span> <span class="o">=</span> <span class="n">kernel_interface</span><span class="o">.</span><span class="n">get_kernel_ptr</span><span class="p">()</span>
        <span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_kernel_ptr</span><span class="p">(</span><span class="n">kern1</span><span class="p">)</span>
        <span class="n">kernel_interface</span><span class="o">.</span><span class="n">pipe_kernel_ptr</span><span class="p">(</span><span class="n">kern2</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.init">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.init">[docs]</a>
    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="p">[],</span> <span class="n">y</span><span class="o">=</span><span class="p">[],</span> <span class="n">z</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">set_codpy_kernel</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;set_codpy_kernel&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_codpy_kernel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_codpy_kernel</span><span class="p">()</span>
        <span class="n">rescale</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rescale&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="n">kernel_interface</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_interface.set_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_kernel</span><span class="p">(</span><span class="n">kernel_key</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">check_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">extras</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An utility to instruct codpy to set a kernel. The list of available kernels is given by :func:`factories.get_map_factory_keys()`</span>

<span class="sd">        Args:</span>

<span class="sd">            kernel_key : (:class:`str`). Must be in  :func:`factories.get_map_factory_keys()`</span>
<span class="sd">            reg : (:class:`float`). Set a regularization parameters. See :func:`kernel_interface.set_regularization`</span>
<span class="sd">            check_ : (:class:`bool`). Check if the key is in :func:`factories.get_map_factory_keys()`</span>
<span class="sd">            extras : (:class:`dic(str,str)`). A list of parameters to set the kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">check_</span><span class="p">:</span>
            <span class="n">factories</span><span class="o">.</span><span class="n">check_kernel_strings</span><span class="p">(</span><span class="n">kernel_key</span><span class="p">)</span>
        <span class="n">kernel_ptr</span> <span class="o">=</span> <span class="n">factories</span><span class="o">.</span><span class="n">get_kernel_factory</span><span class="p">()[</span><span class="n">kernel_key</span><span class="p">](</span><span class="n">extras</span><span class="p">)</span>
        <span class="n">kernel_ptr</span><span class="o">.</span><span class="n">set_kernel_ptr</span><span class="p">(</span><span class="n">kernel_ptr</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span></div>



<div class="viewcode-block" id="kernel_interface.set_map">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_interface.set_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_map</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="n">check_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An utility to set an internal codpy map for kernels. The list of available maps is given by :func:`factories.get_map_factory_keys()`</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>

<span class="sd">            strings : (:class:`str` or :class:`list`). A list of maps :</span>
<span class="sd">            </span>
<span class="sd">                - if  :class:`str`: instanciate and set to codpy the map.</span>
<span class="sd">                - if  :class:`list`: instanciate and set to codpy the first map, then &#39;pipe&#39; (means compose) the others maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">check_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kernel_interface</span><span class="o">.</span><span class="n">get_kernel_ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;set a kernel first, see set_kernel&quot;</span><span class="p">)</span>
            <span class="n">check_map_strings</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="p">[</span><span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>
</div>




<div class="viewcode-block" id="map_setters">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters">[docs]</a>
<span class="k">class</span> <span class="nc">map_setters</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of classes / function to manipulate internal codpy maps. </span>
<span class="sd">    Internal codpy maps can be listed using :func:`factories.get_map_factory_keys`</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="map_setters.set">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set">[docs]</a>
    <span class="k">class</span> <span class="nc">set</span><span class="p">:</span>
<div class="viewcode-block" id="map_setters.set.__init__">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set.__init__">[docs]</a>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strings</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strings</span> <span class="o">=</span> <span class="n">strings</span></div>


        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">set_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strings</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_linear_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_linear_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_linear_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a linear map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the linear map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;linear_map&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_affine_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_affine_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_affine_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an affine map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the affine map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;affine_map&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_log_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_log_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_log_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a logarithmic map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the log map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_exp_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_exp_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_exp_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an exponential map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the exponential map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_scale_std_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_scale_std_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_scale_std_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a standard scaling map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the scale standard map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_std&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_erf_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_erf_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_erf_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an error function (ERF) map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the ERF map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_to_erf&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_erfinv_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_erfinv_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_erfinv_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an inverse error function (ERF) map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the inverse ERF map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_to_erfinv&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_scale_factor_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_scale_factor_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_scale_factor_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a scaling factor map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the scale factor map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_scale_factor_helper">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_scale_factor_helper">[docs]</a>
    <span class="k">def</span> <span class="nf">set_scale_factor_helper</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to set a scaling factor map with specified bandwidth.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments, including &#39;bandwidth&#39; for the scale factor map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">map_setters</span><span class="o">.</span><span class="n">set_scale_factor_map</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;h&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">])}</span>
        <span class="p">)()</span></div>


<div class="viewcode-block" id="map_setters.set_unitcube_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_unitcube_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_unitcube_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unit cube map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the unit cube map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_to_unitcube&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_grid_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_grid_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_grid_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a grid map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the grid map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;map_to_grid&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_mean_distance_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_mean_distance_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_mean_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a mean distance map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the mean distance map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_to_mean_distance&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_min_distance_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_min_distance_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_min_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a minimum distance map for the kernel.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the minimum distance map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_map</span><span class="p">(</span><span class="s2">&quot;scale_to_min_distance&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_setters.set_standard_mean_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_standard_mean_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_standard_mean_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a standard mean map pipeline for the kernel.</span>

<span class="sd">        This function sets a mean distance map and then pipes it through the erf-inverse and unit cube maps.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the standard mean map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_mean_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_erfinv_map</span><span class="p">()</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_unitcube_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_setters.set_standard_min_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_standard_min_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_standard_min_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a standard minimum map pipeline for the kernel.</span>

<span class="sd">        This function sets a minimum distance map and then pipes it through the erf-inverse and unit cube maps.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the standard minimum map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_min_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_erfinv_map</span><span class="p">()</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_unitcube_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_setters.set_unitcube_min_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_unitcube_min_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_unitcube_min_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unit cube minimum map pipeline for the kernel.</span>

<span class="sd">        This function sets a minimum distance map and then pipes it through the unit cube map.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the unit cube minimum map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_min_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_unitcube_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_setters.set_unitcube_erfinv_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_unitcube_erfinv_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_unitcube_erfinv_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unit cube erf-inverse map pipeline for the kernel.</span>

<span class="sd">        This function sets an erf-inverse map and then pipes it through the unit cube map.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the unit cube erf-inverse map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_erfinv_map</span><span class="p">()</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_unitcube_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_setters.set_unitcube_mean_map">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.set_unitcube_mean_map">[docs]</a>
    <span class="k">def</span> <span class="nf">set_unitcube_mean_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unit cube mean map pipeline for the kernel.</span>

<span class="sd">        This function sets a mean distance map and then pipes it through the unit cube map.</span>

<span class="sd">        Args:</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the unit cube mean map configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_mean_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_unitcube_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_setters.map_helper">
<a class="viewcode-back" href="../../core.html#codpy.core.map_setters.map_helper">[docs]</a>
    <span class="k">def</span> <span class="nf">map_helper</span><span class="p">(</span><span class="n">map_setter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates a partial function for a specified map setter with provided arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">        - map_setter (function): The map setter function to be used.</span>
<span class="sd">        - **kwargs: Arbitrary keyword arguments for the map setter function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">map_setter</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="kernel_setters">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters">[docs]</a>
<span class="k">class</span> <span class="nc">kernel_setters</span><span class="p">:</span>
<div class="viewcode-block" id="kernel_setters.kernel_helper">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.kernel_helper">[docs]</a>
    <span class="k">def</span> <span class="nf">kernel_helper</span><span class="p">(</span>
        <span class="n">setter</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">setter</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_kernel</span><span class="p">(</span>
        <span class="n">kernel_string</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the kernel function with specified parameters.</span>

<span class="sd">        This method configures the kernel function used in the calculations. It allows setting</span>
<span class="sd">        the type of kernel, its polynomial order, regularization factor, and an optional mapping function.</span>

<span class="sd">        Args:</span>
<span class="sd">        - kernel_string (str): The name of the kernel function to use.</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>

<span class="sd">        The method configures the kernel and its associated parameters, preparing it for use</span>
<span class="sd">        in subsequent calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_polynomial_order</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="n">kernel_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_map</span><span class="p">:</span>
            <span class="n">set_map</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">polynomial_order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linearkernel</span> <span class="o">=</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
                <span class="n">setter</span><span class="o">=</span><span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_linear_regressor_kernel</span><span class="p">,</span>
                <span class="n">polynomial_order</span><span class="o">=</span><span class="n">polynomial_order</span><span class="p">,</span>
                <span class="n">regularization</span><span class="o">=</span><span class="n">regularization</span><span class="p">,</span>
                <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">kernel_interface</span><span class="o">.</span><span class="n">pipe_kernel_fun</span><span class="p">(</span><span class="n">linearkernel</span><span class="p">,</span> <span class="n">regularization</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_linear_regressor_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_linear_regressor_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_linear_regressor_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the linear regression kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_polynomial_order</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="s2">&quot;linear_regressor&quot;</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">set_regularization</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_map</span><span class="p">:</span>
            <span class="n">set_map</span><span class="p">()</span></div>


<div class="viewcode-block" id="kernel_setters.set_absnormkernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_absnormkernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_absnormkernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the absolute norm kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="s2">&quot;absnorm&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_tensornorm_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_tensornorm_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_tensornorm_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the tensor norm kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;tensornorm&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_gaussian_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_gaussian_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_gaussian_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Gaussian kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_matern_tensor_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_matern_tensor_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_matern_tensor_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Matérn tensor kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;materntensor&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


    <span class="n">default_multiquadricnormkernel_map</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_standard_mean_map</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s2">&quot;norm2&quot;</span>
    <span class="p">)</span>

<div class="viewcode-block" id="kernel_setters.set_multiquadricnorm_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_multiquadricnorm_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_multiquadricnorm_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="n">default_multiquadricnormkernel_map</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the multi-quadric norm kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function defined as `default_multiquadricnormkernel_map`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;multiquadricnorm&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


    <span class="n">default_multiquadrictensorkernel_map</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_standard_min_map</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s2">&quot;normifty&quot;</span>
    <span class="p">)</span>

<div class="viewcode-block" id="kernel_setters.set_multiquadrictensor_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_multiquadrictensor_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_multiquadrictensor_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="n">default_multiquadrictensorkernel_map</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the multi-quadric tensor kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function defined as `default_multiquadrictensorkernel_map`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;multiquadrictensor&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


    <span class="n">default_sincardtensorkernel_map</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_min_distance_map</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s2">&quot;normifty&quot;</span>
    <span class="p">)</span>

<div class="viewcode-block" id="kernel_setters.set_sincardtensor_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_sincardtensor_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sincardtensor_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="n">default_sincardtensorkernel_map</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the sinc cardinal tensor kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function defined as `default_sincardtensorkernel_map`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;sincardtensor&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


    <span class="n">default_sincardsquaretensorkernel_map</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">map_setters</span><span class="o">.</span><span class="n">set_min_distance_map</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s2">&quot;normifty&quot;</span>
    <span class="p">)</span>

<div class="viewcode-block" id="kernel_setters.set_sincardsquaretensor_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_sincardsquaretensor_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sincardsquaretensor_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="n">default_sincardsquaretensorkernel_map</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the sinc cardinal square tensor kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function defined as `default_sincardsquaretensorkernel_map`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;sincardsquaretensor&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_dotproduct_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_dotproduct_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_dotproduct_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the dot product kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;DotProduct&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_gaussianper_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_gaussianper_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_gaussianper_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Gaussian periodic kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;gaussianper&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_matern_norm_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_matern_norm_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_matern_norm_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">set_map</span><span class="o">=</span><span class="n">map_setters</span><span class="o">.</span><span class="n">set_mean_distance_map</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Matérn norm kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function defined as `map_setters.set_mean_distance_map`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;maternnorm&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="kernel_setters.set_scalar_product_kernel">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setters.set_scalar_product_kernel">[docs]</a>
    <span class="k">def</span> <span class="nf">set_scalar_product_kernel</span><span class="p">(</span>
        <span class="n">polynomial_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">set_map</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the scalar product kernel with specified parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        - regularization (float): The regularization parameter for the kernel.</span>
<span class="sd">        - set_map (callable, optional): An optional mapping function to apply.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_kernel</span><span class="p">(</span>
            <span class="s2">&quot;scalar_product&quot;</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">set_map</span>
        <span class="p">)</span></div>
</div>



<span class="k">class</span> <span class="nc">_pipe__map_setters</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cd</span><span class="o">.</span><span class="n">kernel_interface</span><span class="o">.</span><span class="n">pipe_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_log_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_exp_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_linear_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;linear_map&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_affine_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe_affine_map</span><span class="p">(</span><span class="s2">&quot;affine_map&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_scale_std_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_std&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_erf_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_to_erf&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_erfinv_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_to_erfinv&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_unitcube_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_to_unitcube&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_mean_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_to_mean_distance&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pipe_min_distance_map</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_pipe__map_setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s2">&quot;scale_to_min_distance&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">kernel_settings</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_linear_regressor_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_gaussian_kernel</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">map_func</span>
    <span class="p">),</span>
    <span class="s2">&quot;tensornorm&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_tensornorm_kernel</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">map_func</span>
    <span class="p">),</span>
    <span class="s2">&quot;absnorm&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_absnormkernel</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">map_func</span>
    <span class="p">),</span>
    <span class="s2">&quot;matern&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_matern_tensor_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;multiquadricnorm&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_multiquadricnorm_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;multiquadrictensor&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_multiquadrictensor_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;sincardtensor&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_sincardtensor_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;sincardsquaretensor&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_sincardsquaretensor_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;dotproduct&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_dotproduct_kernel</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">map_func</span>
    <span class="p">),</span>
    <span class="s2">&quot;gaussianper&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_gaussianper_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;maternnorm&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_matern_norm_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;scalarproduct&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">polynomial_order</span><span class="p">,</span>
    <span class="n">regularization</span><span class="p">,</span>
    <span class="n">map_func</span><span class="p">:</span> <span class="n">kernel_setters</span><span class="o">.</span><span class="n">kernel_helper</span><span class="p">(</span>
        <span class="n">kernel_setters</span><span class="o">.</span><span class="n">set_scalar_product_kernel</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">,</span>
        <span class="n">map_func</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">}</span>

<span class="n">_map_settings</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_linear_map</span><span class="p">,</span>
    <span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_affine_map</span><span class="p">,</span>
    <span class="s2">&quot;log&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_log_map</span><span class="p">,</span>
    <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_exp_map</span><span class="p">,</span>
    <span class="s2">&quot;scalestd&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_scale_std_map</span><span class="p">,</span>
    <span class="s2">&quot;erf&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_erf_map</span><span class="p">,</span>
    <span class="s2">&quot;erfinv&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_erfinv_map</span><span class="p">,</span>
    <span class="s2">&quot;scalefactor&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_scale_factor_map</span><span class="p">,</span>
    <span class="s2">&quot;bandwidth&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_scale_factor_helper</span><span class="p">,</span>
    <span class="s2">&quot;grid&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_grid_map</span><span class="p">,</span>
    <span class="s2">&quot;unitcube&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_unitcube_map</span><span class="p">,</span>
    <span class="s2">&quot;meandistance&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_mean_distance_map</span><span class="p">,</span>
    <span class="s2">&quot;mindistance&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_min_distance_map</span><span class="p">,</span>
    <span class="s2">&quot;standardmin&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_standard_min_map</span><span class="p">,</span>
    <span class="s2">&quot;standardmean&quot;</span><span class="p">:</span> <span class="n">map_setters</span><span class="o">.</span><span class="n">set_standard_mean_map</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_requires_rescale</span><span class="p">(</span><span class="n">map_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">maps_needing_rescale</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;unitcube&quot;</span><span class="p">,</span>
        <span class="s2">&quot;meandistance&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mindistance&quot;</span><span class="p">,</span>
        <span class="s2">&quot;standardmin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;standardmean&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="n">maps_needing_rescale</span>


<span class="k">def</span> <span class="nf">_requires_bandwidth</span><span class="p">(</span><span class="n">map_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">bandwidth_required_maps</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="n">bandwidth_required_maps</span>


<span class="k">def</span> <span class="nf">_kernel_helper2</span><span class="p">(</span>
    <span class="n">kernel</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">1.0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the kernel function with specified parameters using string identifiers.</span>

<span class="sd">    Args:</span>
<span class="sd">        kernel (str): The name of the kernel function to use.</span>
<span class="sd">        map (str): The name of the mapping function to use.</span>
<span class="sd">        polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        regularization (float): The regularization parameter for the kernel.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The configured kernel function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel_func_creator</span> <span class="o">=</span> <span class="n">kernel_settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">map_func</span> <span class="o">=</span> <span class="n">_map_settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kernel_func_creator</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Kernel &#39;</span><span class="si">{</span><span class="n">kernel</span><span class="si">}</span><span class="s2">&#39; not recognized.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map_func</span> <span class="o">=</span> <span class="n">_map_settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">map_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map &#39;</span><span class="si">{</span><span class="nb">map</span><span class="si">}</span><span class="s2">&#39; not recognized.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_requires_bandwidth</span><span class="p">(</span><span class="nb">map</span><span class="p">):</span>
            <span class="n">map_func</span> <span class="o">=</span> <span class="n">map_func</span><span class="p">(</span><span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">map_func</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">kernel_func</span> <span class="o">=</span> <span class="n">kernel_func_creator</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">kernel_func</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">map_func</span><span class="p">)()</span>


<div class="viewcode-block" id="kernel_setter">
<a class="viewcode-back" href="../../core.html#codpy.core.kernel_setter">[docs]</a>
<span class="k">def</span> <span class="nf">kernel_setter</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">regularization</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the kernel function with specified parameters using string identifiers.</span>

<span class="sd">    Args:</span>
<span class="sd">        kernel (str): The name of the kernel function to use.</span>
<span class="sd">        map (str): The name of the mapping function to use.</span>
<span class="sd">        polynomial_order (int): The polynomial order for the kernel function.</span>
<span class="sd">        regularization (float): The regularization parameter for the kernel.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The configured kernel function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">_kernel_helper2</span><span class="p">(</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">polynomial_order</span><span class="p">,</span> <span class="n">regularization</span><span class="p">,</span> <span class="n">bandwidth</span>
    <span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">pass</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jean-Marc MERCIER, Shohruh MIRYUSUPOV.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>